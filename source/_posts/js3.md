
---
title: js第三天
tags: [笔记,随笔,美文]
categories: 笔记
---





# 函数

> 学习目标：掌握函数的基本用法，会使用函数解决一些问题。



## 函数基础知识
### 为什么要有函数

> 在写代码的时候，有一些常用的代码需要书写多次，如果直接复制粘贴的话，会造成大量的冗余代码。
>
> 函数可以封装一段重复的JavaScript代码，它只需要声明一次，就可以被多次调用。

冗余代码的缺点：

1.   代码重复，可阅读性差

2.   不易维护，如果代码逻辑改变了，所有地方的代码都要跟着改变，效率太低。




### 函数的声明与调用

声明函数的语法：

```javascript
function 函数名(){
	//函数体
}
```

特点：

	1. 函数声明的时候，函数体并不会执行，只要当函数被调用的时候才会执行。
	2. 函数一般都用来干一件事情，需用使用动词+名词，表示做一件事情 `tellStory` `sayHello`等



调用函数的语法：

```javascript
函数名();
```

特点：

	1. 函数体只有在调用的时候才会执行，调用需要<font color="red">()</font>进行调用。
	2. 可以调用多次



代码示例：

```javascript
//声明函数
function sayHi(){
  console.log("吃了没？");
}
//调用函数
sayHi();
```



思考：

```javascript
1. 封装一个打招呼的函数
2. 封装一个函数，计算两个数的和
3. 封装一个函数，计算1-100之间所有数的和
```



### 函数的参数

> 1. 形式参数：在声明一个函数的时候，为了函数的功能更加灵活，有些值是固定不了的，对于这些固定不了的值。我们可以给函数设置参数。这个参数没有具体的值，仅仅起到一个占位置的作用，我们通常称之为形式参数，也叫形参。
> 2. 实际参数：如果函数在声明时，设置了行参，那么在函数调用的时候就需要传入对应的参数，我们把传入的参数叫做实际参数，也叫实参。

语法：

```javascript
//带参数的函数声明
function 函数名(形参1, 形参2, 形参...){
  //函数体
}

//带参数的函数调用
函数名(实参1, 实参2, 实参3);
```



思考：

```javascript
1. 计算1-n之间所有数的和
2. 计算两个数的和
3. 计算m-n之间所有数的积
```



### 函数的返回值


>当函数执行完的时候，我们期望函数给我一些反馈（比如计算的结果），这个时候可以让函数返回一些东西。也就是返回值。函数通过return返回一个返回值

返回值语法：

```javascript
//声明一个带返回值的函数
function 函数名(形参1, 形参2, 形参...){
  //函数体
  return 返回值;
}

//可以通过变量来接收这个返回值
var 变量 = 函数名(实参1, 实参2, 实参3);
```

<font color="red">函数的调用结果就是返回值，因此我们可以直接对函数调用结果进行操作。</font>



思考：

```javascript
1. 计算1-n之间所有数的和,并且返回结果
2. 计算两个数的和，并且返回结果
3. 计算m-n之间所有数的积，并且返回结果
```



### 函数三要素

函数三要素包括：函数名、参数、返回值

关于文档注释，javascript中还有一种注释叫做文档注释，经常用在函数声明处，用来解释这个函数的作用。

文档注释： /**   这是文档注释 */

<font color="red">以后写的函数的声明，都应该加上文档注释，方便阅读</font>

```javascript
/**
 * 求圆的面积
 * @param r {number} 圆的半径
 * @returns {number} 圆的周长
 */
function getArea (r) {
    return Math.PI * r * r;
}

```



思考1：

```javascript
1. 求任意半径的圆的面积
2. 求任意半径的圆的周长
3. 求任意2个数中的最大值
```



思考2：

```javascript
1. 求任意数组中的最大值
2. 求任意数组中的最小值
3. 翻转任意数组，返回一个新的数组
4. 对任意数组从小到大排序
```



## 函数高级知识

### 函数调试

> 在函数内部是可以继续调用别的函数的。

```javascript
function fn1() {
    console.log("fn1开始...");
    fn2();
    console.log("fn1结束...");
}

function fn2 () {
    console.log("执行fn2的代码"); 
	console.log("执行fn2的代码");
	console.log("执行fn2的代码");
}

//在函数1中调用了函数2
fn1();
```



断点调试：

```javascript
1.	F8：跳到下一个断点，如果后面没有断点了，那么代码直接执行完。
2.	F10：单步调试（跳过函数调用）
3.	F11：单步调试（进入函数调用）
4.	shift+F11：跳出函数调用
```



思考：

```javascript
1. 求阶乘
2. 求阶乘的和
3. 求任意3个数中的最大值
```



### 函数参数与返回值详解

函数的参数详解：

1. 在javascript中，没有函数重载，只有覆盖，如果定义了两个同名的函数，后面的函数会覆盖掉前面的函数。

2. 在javascript，实参的个数可以和形参的个数不一致

   + 如果实参的个数多于形参的个数，多余的参数会被舍弃。
   + 如果实参的个数少于形参的个数，缺少的实参是undefined。

   ​

函数的返回值详解：

	1. return 后面的语句不会执行
	2. 函数可以没有返回值，会在函数的最后面默认返回一个undefined
	3. 函数也可以直接写return，相当于return undefined,此时的作用就是结束函数的调用。



思考：

```javascript
1. 比较两个数的大小，返回更大的那个数。
2. 求数组中的最大值和最小值，并且返回
```



### 函数的作用域

全局变量：在最外层声明的变量就是全局变量，全局变量在任何地方都能访问的到。

局部变量：在函数中声明的变量，就是局部变量，局部变量只有在当前函数体内能够访问。

隐式全局变量：没有使用var定义的变量也是全局变量。



作用域：变量可以发挥作用的区域

全局作用域：在script标签内，函数外定义的作用域就是全局作用域。在全局作用域中定义的变量都是全局变量。

函数作用域：在函数中的区域叫做函数作用域，在函数作用域中定义的变量就是局部变量，只能在当前函数内访问。

<font color="red">在函数中，只有全局作用域和函数作用域，因为在if、while、for等语句中定义的变量都是全局变量。</font>



### 预解析

> js解析器执行js代码的时候，分为两个过程：预解析过程和代码执行过程

预解析过程：

1. 把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值。
2. 把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用。
3. 先提升var，在提升function



思考：

```javascript
//1. getCool
//2.
console.log(a);
function a() {
  console.log("aaaaa");
}
var a = 1;
console.log(a);
```





面试题：

```javascript
//1. 
var num = 10;
fn1();
function fn1() {
  console.log(num);//undefined
  var num = 20;
}

//2. 
var a = 18;
fn2();
function fn2() {
    var b = 9;
    console.log(a);
    console.log(b);
}

//3.
fn3();
console.log(c);
console.log(b);
console.log(a);
function fn3() {
  a = b = c = 9;
  console.log(a);
  console.log(b);
  console.log(c);
}
```



### 声明函数的两种方式

函数声明(命名函数)：

```javascript
function 函数名(){
  //函数体
}
```

函数表达式(匿名函数)：

```javascript
var 函数名 = function(){
  //函数体
}
```



这两种函数声明的区别：

1. 命名函数可以先调用，在声明，因为预解析
2. 函数表达式必须先声明，再调用（在DOM中注册事件的时候用的非常的多）



### 匿名函数

> 匿名函数：没有名字的函数

匿名函数如何使用：

	1. 将匿名函数赋值给一个变量，这样就可以通过变量进行调用
	2. 匿名函数自调用



关于自执行函数（匿名函数自调用）的作用：防止全局变量污染。





